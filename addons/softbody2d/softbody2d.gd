@tool
@icon("res://addons/softbody2d/plugin_icon.png")
extends Polygon2D

## A 2D Softbody.
##
## Models an object as a softbody by creating:[br]
## - a set of [RigidBody2D] nodes, each with one [CollisionShape2D] with a [Shape2D] and a set of [Joint2D] nodes connected to adjacent bodies.[br]
## - one [Skeleton2D] node with a set of [Bone2D] nodes, each getting their position set from a [RemoteTransform2D] node, located on the rigidbodies.[br]
##
## How it does it:[br]
## [br]
## [b]Polygon[/b]:[br]
## 1. Creates edge vertices from texture.[br]
## 2. Creates multiple voronoi regions with roughly same total size as the edge vertices AABB.[br]
## 3. Delete the voronoi regions not inside the polygon.[br]
## 4. Assigns these polygons to the [member Polygon2D.polygon] and [member Polygon2D.polygons][br]
## [br]
## [b]Skeleton2D[/b]:[br]
## 1. Creates a [Skeleton2D] child.[br]
## 2. Creates a set of [Bone2D] nodes of the [Skeleton2D], each having a voronoi region and assign correct weights to them.[br]
## [br]
## [b]RigidtBody2D[/b]:[br]
## 1. Creates a set of [RigidBody2D] nodes, one for each voronoi region.[br]
## 2. Creates for each [Bone2D] a [Rigidody2D] with a [CollisionShape2D] (with a [Shape2D] shape) child, a [RemoteTransform2D] child that targets thte [Bone2D] position, and either [DampedSprintJoint2D] or [PinJoint2D] children that connects each other neighbour nodes.[br]
##
## @tutorial: https://github.com/Ughuuu/godot-4-softbody2d/tree/main

class_name SoftBody2D



## Bake the softbody.
@export var bake := false :
	set (value):
		if value != false:
			if vertex_interval < radius:
				push_warning("Vertex Interval is less than Radius. This will create bigger bigger shapes than needed.")
			create_softbody2d()
	get:
		return false
	
## Clears all the children nodes generated by bake_softbody.
@export var clear := false :
	set (value):
		if value != false:
			clear_softbody2d()
	get:
		return false


## If these are changed at runtime, no changes will be made unless you call bake.
@export_group("Polygon")

## Random seed for generation of voronoi regions
@export var voronoi_rand_seed : int= 0
## Distance between internal vertices
@export_range(2, 50, 1, "or_greater") var vertex_interval := 20
## How far randomly should the points move.
@export_range(0.01, 0.5, 0.05) var voronoi_interval:= 0.15
## Offset from Texture Center for the polygon. Use this if some rigidbodies are positioned weirdly.
@export var polygon_offset := Vector2()
## Minimum area of a region that was cut. If it's less than this, it will be added to another region close to it.
@export_range(0.01, 1, 0.01) var min_area:= 0.4

## If these are changed at runtime, no changes will be made unless you call bake.
@export_group("Image")
## Amount to grow or shrink the image with in pixels. Adds dilatation if positive, if negative adds erosion.
@export_range(-50, 50, 1, "or_grater") var margin_pixels := 0
## Epsilon for making polygon from texture. Smaller value results in more accurate result, but more vertices
@export_range(0.1, 50, 0.01, "or_greater") var texture_epsilon := 1
## Min alpha to consider the point part of polygon
@export_range(0.01, 1, 0.01, "or_greater") var min_alpha := 0.05

## Only [member SoftBody2D.bias], [member SoftBody2D.disable_collision], [member SoftBody2D.stiffness], [member SoftBody2D.damping] and [member SoftBody2D.softness] can be changed at runtime.
@export_group("Joint")
## Wether to look_at center bone(if not breakable) or to look at adjacent center bone. Usually look_at_center gives better results.
@export var look_at_center := true
## The joint type. Pin yields a more sturdy softbody, and uses [PinJoint2D], while sprint a more soft one, and uses [DampedSpringJoint2D].
@export_enum("pin", "spring") var joint_type:= "pin"
## Sets the [member Joint2D.bias] property of the joint.[br]Can be changed at runtime.
@export_range(0, 2, 0.1, "or_greater") var bias : float = 0 :
	set (value):
		if bias == value:
			return
		bias = value
		for body in get_rigid_bodies():
			for joint in body.joints:
				joint.bias = bias
	get:
		return bias

## Sets the [member Joint2D.disable_collision] property of the joint.[br]Can be changed at runtime.
@export var disable_collision := false :
	set (value):
		if disable_collision == value:
			return
		disable_collision = value
		for body in get_rigid_bodies():
			for joint in body.joints:
				joint.disable_collision = disable_collision
	get:
		return disable_collision
@export_subgroup("DampedSpringJoint")
## Relevant only if you picked [member SoftBody2D.joint_type] = "spring". Sets the [member DampedSpringJoint2D.stiffness] property of the joint.[br]Can be changed at runtime.
@export_range(0.1, 128, 0.1, "or_greater") var stiffness: float = 20  :
	set (value):
		if stiffness == value:
			return
		stiffness = value
		for body in get_rigid_bodies():
			for joint in body.joints:
				if joint is DampedSpringJoint2D:
					joint.stiffness = stiffness
	get:
		return stiffness
## Relevant only if you picked [member SoftBody2D.joint_type] = "spring". Sets the [member DampedSpringJoint2D.damping] property of the joint.[br]Can be changed at runtime.
@export_range(0.1, 16, 0.1, "or_greater") var damping: float = 0.7  :
	set (value):
		if damping == value:
			return
		damping = value
		for body in get_rigid_bodies():
			for joint in body.joints:
				if joint is DampedSpringJoint2D:
					joint.damping = damping
	get:
		return damping
@export_subgroup("PinJoint")
## Relevant only if you picked [member SoftBody2D.joint_type] = "pin". Sets the [member PinJoint2D.softness] property of the joint.[br]Can be changed at runtime.
@export_range(0, 100, 0.1, "or_greater") var softness: float = 16 :
	set (value):
		if softness == value:
			return
		softness = value
		for body in get_rigid_bodies():
			for joint in body.joints:
				if joint is PinJoint2D:
					joint.softness = softness
	get:
		return softness

## All these properties can be changed at runtime.
@export_group("RigidBody")
## What kind of shape to create for each rigidbody.[br]Can be changed at runtime.
@export_enum("Circle", "Rectangle") var shape_type:= "Circle" :
	set (value):
		if shape_type == value:
			return
		shape_type = value
		for body in get_rigid_bodies():
			var shape = body.shape
			if shape_type == "Circle":
				shape.shape = CircleShape2D.new()
				shape.shape.radius = radius / 2.0
			elif shape_type == "Rectangle":
				shape.shape = RectangleShape2D.new()
				shape.shape.size = Vector2(radius, radius)
			else:
				push_error("Wrong shape used for shape_type")
	get:
		return shape_type
## Sets the [member Shape2D size].[br]Can be changed at runtime.
@export_range(2, 50, 1, "or_greater") var radius := 30 :
	set (value):
		if radius == value:
			return
		radius = value
		for body in get_rigid_bodies():
			var shape = body.shape
			if shape_type == "Circle":
				shape.shape.radius = radius / 2.0
			elif shape_type == "Circle":
				shape.shape.size = Vector2(radius, radius)
			else:
				push_error("Wrong shape used for shape_type")
	get:
		return radius
## Sets the [member RigidBody2D.collision_layer].[br]Can be changed at runtime.
@export_flags_2d_physics var collision_layer := 1 :
	set (value):
		if collision_layer == value:
			return
		collision_layer = value
		for body in get_rigid_bodies():
			body.rigidbody.collision_layer = collision_layer
	get:
		return collision_layer
## Sets the [member RigidBody2D.collision_mask].[br]Can be changed at runtime.
@export_flags_2d_physics var collision_mask := 1 :
	set (value):
		if collision_mask == value:
			return
		collision_mask = value
		for body in get_rigid_bodies():
			body.rigidbody.collision_mask = collision_mask
	get:
		return collision_mask
## Sets the [member RigidBody2D.mass].[br]Can be changed at runtime.
@export_range(0, 100) var mass := 0.01 :
	set (value):
		if mass == value:
			return
		mass = value
		call_deferred("_update_bodies_mass")
	get:
		return mass
## If true, makes the center most rigidbodies have less mass.[br]Can be changed at runtime.
@export var soft_on_inside: bool = false :
	set (value):
		if soft_on_inside == value:
			return
		soft_on_inside = value
		call_deferred("_update_bodies_mass")
	get:
		return soft_on_inside

func _update_bodies_mass():
	var bones = get_node(skeleton).get_children()
	var center_bone := _get_node_to_follow(bones)
	var polygon_limits = _calculate_polygon_limits()
	var max_dist_sq = polygon_limits[0].distance_squared_to(polygon_limits[1])/4
	for body in get_rigid_bodies():
		var distance_ratio = 1
		if soft_on_inside:
			var current_distance = body.rigidbody.global_position.distance_squared_to(center_bone.global_position)
			if (current_distance <= 0.00001):
				current_distance = 0.00001
			distance_ratio = current_distance/max_dist_sq + 0.01
		body.rigidbody.mass = mass * distance_ratio

## Sets a script to attach the [RigidBody2D] created.[br]Can be changed at runtime.
@export var rigidbody_script : Script :
	set (value):
		if rigidbody_script == value:
			return
		rigidbody_script = value
		for body in get_rigid_bodies():
			body.rigidbody.set_script(rigidbody_script)
	get:
		return rigidbody_script
## Sets the [member RigidBody2D.pickable].[br]Can be changed at runtime.
@export var pickable := false :
	set (value):
		if pickable == value:
			return
		pickable = value
		for body in get_rigid_bodies():
			body.rigidbody.input_pickable = pickable
	get:
		return pickable
## Sets the [member RigidBody2D.lock_rotation].[br]Can be changed at runtime.
@export var lock_rotation := false :
	set (value):
		if lock_rotation == value:
			return
		lock_rotation = value
		for body in get_rigid_bodies():
			body.rigidbody.lock_rotation = lock_rotation
	get:
		return lock_rotation
## Sets the [member RigidBody2D.physics_material_override].[br]Can be changed at runtime.
@export var physics_material_override: PhysicsMaterial :
	set (value):
		if physics_material_override == value:
			return
		physics_material_override = value
		for body in get_rigid_bodies():
			body.rigidbody.physics_material_override = physics_material_override
	get:
		return physics_material_override

@export_group("Debug")
## Draw voronoi region of edge polygon.[br]
## 1a. Creates edge vertices from texture.[br]
## 1b. Creates multiple voronoi regions with roughly same total size as the edge vertices AABB.[br]
## 1c. Delete the voronoi regions not inside the polygon.[br]
@export var draw_voronoi := false :
	set (value):
		if value != false:
			clear_softbody2d()
			var voronoi_regions = _create_polygon2d()
			if (!voronoi_regions):
				return
			var voronoi_node:= Voronoi2D.new()
			add_child(voronoi_node)
			var polygon_limits = _calculate_polygon_limits()
			var lim_min = polygon_limits[0]
			var lim_max = polygon_limits[1]
			var polygon_size = lim_max - lim_min
			voronoi_node.size = polygon_size;
			voronoi_node.distance_between_points = vertex_interval
			if Engine.is_editor_hint():
				voronoi_node.set_owner(get_tree().get_edited_scene_root())
			voronoi_node.draw_voronoi(voronoi_regions[0])
	get:
		return false

## Call this to create a new softbody at runtime.
func create_softbody2d():
	var voronoi = _create_polygon2d()
	if (!voronoi):
		return
	var skeleton2d = _construct_skeleton2d(voronoi[0], voronoi[1])
	_create_rigidbodies2d(skeleton2d)
	_update_soft_body_rigidbodies()

## Call this to clear all children, polygons and bones.
func clear_softbody2d():
	_clear_polygon()
	for child in get_children():
		child.queue_free()
		remove_child(child)
	clear_bones()
	_update_soft_body_rigidbodies()

func _clear_polygon():
	polygon.clear()
	polygons.clear()
	uv.clear()
	internal_vertex_count = 0

func _create_polygon2d():
	if texture == null:
		push_error("Texture is required to generate SoftBody2D")
		return
	_create_external_vertices_from_texture()
	return _create_internal_vertices()

func _get_polygon_verts():
	var polygon_verts = polygon.duplicate()
	if polygon_verts.size() != 0:
		var new_size = polygon_verts.size() - internal_vertex_count
		if new_size > 0:
			polygon_verts.resize(new_size)
	return polygon_verts

func _create_external_vertices_from_texture():
	skeleton = ""
	var bitmap = BitMap.new()
	bitmap.create_from_image_alpha(texture.get_image(), min_alpha)
	var rect = Rect2(0, 0, texture.get_width(), texture.get_height())
	if margin_pixels != 0:
		bitmap.grow_mask(margin_pixels, rect)
	var poly = bitmap.opaque_to_polygons(rect, texture_epsilon)
	if poly.is_empty():
		push_error("Could not generate polygon outline")
	if poly.size() != 1:
		var resulting_poly = PackedVector2Array()
		for poly_b in poly:
			var merged_polygon := Geometry2D.merge_polygons(resulting_poly, poly_b)
			if merged_polygon.size() != 1:
				push_error("More than 1 polygon resulted from image. Tried to merge them but failed. Try to change the min_alpha to something higher.")
				break
			resulting_poly = merged_polygon[0]
		poly[0] = resulting_poly
	if poly[0].is_empty():
		push_error("Resulting polygon is empty")
	set_polygon(PackedVector2Array(poly[0]))
	set_uv(PackedVector2Array([]))

func _polygon_area(polygon_verts: PackedVector2Array) -> float:
	var area := 0.0;

	for i in polygon_verts.size():
		var j = (i + 1)%polygon_verts.size();
		area += 0.5 * (polygon_verts[i].x*polygon_verts[j].y -  polygon_verts[j].x*polygon_verts[i].y);

	return area

func _minv(curvec,newvec):
	return Vector2(min(curvec.x,newvec.x),min(curvec.y,newvec.y))

func _maxv(curvec,newvec):
	return Vector2(max(curvec.x,newvec.x),max(curvec.y,newvec.y))

func _polygon_center(polygon_verts: Array[PackedVector2Array]) -> Vector2:
	var min_vec = polygon_verts[0][0]
	var max_vec = polygon_verts[0][0]
	for poly in polygon_verts:
		for i in poly.size():
			min_vec = _minv(min_vec, poly[i])
			max_vec = _maxv(max_vec, poly[i])
	return min_vec + (max_vec - min_vec)/2
	
func _generate_points_voronoi(lim_min: Vector2, lim_max: Vector2, polygon_verts):
	var polygon_size = lim_max - lim_min
	var polygon_num = Vector2(int(polygon_size.x / vertex_interval), int(polygon_size.y / vertex_interval))
	var voronoi = Voronoi2D.generate_voronoi(polygon_size * 1.2, vertex_interval, \
		lim_min + polygon_offset, voronoi_interval, voronoi_rand_seed)
	var polygons = []
	var new_voronoi: Array[Voronoi2D.VoronoiRegion2D]
	var voronoi_regions_to_move = []
	# find out what regions to remove
	for region_idx in len(voronoi):
		var each: Voronoi2D.VoronoiRegion2D = voronoi[region_idx]
		var total_area := _polygon_area(each.polygon_points[0])
		var is_middle_inside = _is_point_in_area(each.fixed_center, polygon_verts, 1.1)
		
		var is_inside = true
		# if there is a point not inside the polygon vertices, cut it.
		# it may result in multiple polygons
		for polygon_vert in each.polygon_points[0]:
			if not _is_point_in_area(polygon_vert, polygon_verts, 1.1):
				is_inside = false
				var intersect = Geometry2D.intersect_polygons(polygon_verts, each.polygon_points[0])
				if (intersect.is_empty()):
					# no intersection, polygon is outside
					break
				each.polygon_points = []
				each.polygon_points.append_array(intersect)
				# update center if we change the polygon
				each.fixed_center = _polygon_center(each.polygon_points)
				each.center = _polygon_center(each.polygon_points)
				new_voronoi.append(each)
				var cut_area := 0.0
				for intersected in intersect:
					cut_area += _polygon_area(intersected)
				# if area of polygon is too smal, move it to another region
				if cut_area / total_area < min_area || !is_middle_inside:
					voronoi_regions_to_move.append(new_voronoi.size() - 1)
				break
		if is_inside:
			new_voronoi.append(each)
	# move regions first
	for region_to_move in voronoi_regions_to_move:
		var dist := -1.0
		var closest_idx := -1
		var to_remove = new_voronoi[region_to_move]
		for voronoi_idx in len(new_voronoi):
			if voronoi_idx in voronoi_regions_to_move:
				continue
			var each = new_voronoi[voronoi_idx]
			var current_dist = each.fixed_center.distance_to(to_remove.fixed_center)
			if dist < 0 or dist > current_dist:
				dist = current_dist
				closest_idx = voronoi_idx
		new_voronoi[closest_idx].polygon_points.append_array(to_remove.polygon_points)
		# update center if we change the polygon
		new_voronoi[closest_idx].fixed_center = _polygon_center(new_voronoi[closest_idx].polygon_points)
		new_voronoi[closest_idx].center = _polygon_center(new_voronoi[closest_idx].polygon_points)
	voronoi_regions_to_move.sort_custom(func (x,y): return x>y)
	# remove them
	for region_to_move in voronoi_regions_to_move:
		new_voronoi.remove_at(region_to_move)
	# add remaining
	var new_vert = get_polygon()
	var bone_vert_arr = []
	var in_vert_count = 0
	for each in new_voronoi:
		# multiple polygons
		var bone_vert_combined_array := []
		for poly in each.polygon_points:
			polygons.append_array(_triangulate_polygon(poly, polygon_verts, len(new_vert)))
			var bone_vert_arr_el = []
			for vert in poly:
				bone_vert_arr_el.append(len(new_vert))
				new_vert.append(vert)
				in_vert_count += 1
			bone_vert_combined_array.append_array(bone_vert_arr_el)
		bone_vert_arr.append(bone_vert_combined_array)
	set_polygon(new_vert)
	set_internal_vertex_count(in_vert_count)
	set_polygons(polygons)
	return [new_voronoi, bone_vert_arr]

func _create_internal_vertices():
	var polygon_verts = _get_polygon_verts()
	var polygon_limits = _calculate_polygon_limits()
	var lim_min = polygon_limits[0]
	var lim_max = polygon_limits[1]
	var polygon_size = lim_max - lim_min
	var polygon_num = Vector2(int(polygon_size.x / vertex_interval), int(polygon_size.y / vertex_interval))
	return _generate_points_voronoi(lim_min, lim_max, polygon_verts)

func _calculate_polygon_limits() -> Array[Vector2]:
	var lim_min = polygon[0]
	var lim_max = polygon[0]
	for point in polygon:
		if point.x < lim_min.x:
			lim_min.x = point.x
		if point.x > lim_max.x:
			lim_max.x = point.x
		if point.y < lim_min.y:
			lim_min.y = point.y
		if point.y > lim_max.y:
			lim_max.y = point.y
	return [lim_min, lim_max]

func _is_point_in_area(point: Vector2, polygon_verts: PackedVector2Array, scale_amount := 1.1) -> bool:
	var scaled_poly = polygon_verts.duplicate()
	var center = Vector2()
	for vert in polygon_verts:
		center = center + vert
	center = center / len(polygon_verts)
	for i in len(scaled_poly):
		scaled_poly[i] = (scaled_poly[i] - center) * scale_amount + center
	return Geometry2D.is_point_in_polygon(point, scaled_poly)

func _triangulate_polygon(polygon: PackedVector2Array, polygon_verts: PackedVector2Array, offset:= 0, validate_inside:= false):
	var points = Array(Geometry2D.triangulate_polygon(polygon))
	var polygons = []
	for i in range(ceil(len(points) / 3)):
		var triangle = []
		for n in range(3):
			triangle.append(points.pop_front() + offset)
		var a = polygon[triangle[0] - offset]
		var b = polygon[triangle[1] - offset]
		var c = polygon[triangle[2] - offset]
		if validate_inside:
			if _is_line_in_area(a,b, polygon_verts) and _is_line_in_area(b,c, polygon_verts) and _is_line_in_area(c,a, polygon_verts):
				polygons.append(PackedInt32Array(triangle))
		else:
			polygons.append(PackedInt32Array(triangle))
	return polygons


func _is_line_in_area(a: Vector2, b: Vector2, polygon_verts: PackedVector2Array) -> bool:
	return _is_point_in_area(a + a.direction_to(b) * 0.01, polygon_verts) \
		and _is_point_in_area(b + b.direction_to(a) * 0.01, polygon_verts) \
		and _is_point_in_area((a + b) / 2, polygon_verts)


func _create_skeleton() -> Skeleton2D:
	var skeleton2d = Skeleton2D.new()
	skeleton2d.name = "Skeleton2D"
	add_child(skeleton2d)
	if Engine.is_editor_hint():
		skeleton2d.set_owner(get_tree().get_edited_scene_root())
	skeleton = NodePath(skeleton2d.name)
	clear_bones()
	return skeleton2d

func _construct_skeleton2d(voronoi: Array, bone_vert_arr) -> Skeleton2D:
	var skeleton_nodes = get_children().filter(func (node): return node is Skeleton2D)
	var skeleton2d : Skeleton2D
	if len(skeleton_nodes) == 0:
		print("Skeleton2D is null. Creating one for you.")
		skeleton2d = _create_skeleton()
	else:
		skeleton2d = skeleton_nodes[0] as Skeleton2D
	skeleton = NodePath(skeleton2d.name)
	skeleton2d.position = Vector2()
	for child in skeleton2d.get_children():
		child.queue_free()
		skeleton2d.remove_child(child)
	clear_bones()
	var bones = _create_bones(voronoi)
	var weights = _generate_weights(bones, voronoi, bone_vert_arr)
	var bone_count = skeleton2d.get_bone_count()
	for bone_index in len(bones):
		var bone : Bone2D = bones[bone_index]
		bone.set_meta("vert_owned", bone_vert_arr[bone_index])
		skeleton2d.add_child(bone)
		add_bone(NodePath(bone.name), PackedFloat32Array(weights[bone_index]))
		if Engine.is_editor_hint():
			bone.set_owner(get_tree().get_edited_scene_root())
	return skeleton2d

func _create_bones(voronoi: Array) -> Array[Bone2D]:
	var bones: Array[Bone2D] = []
	var polygon_limits = _calculate_polygon_limits()
	var polygon_verts = _get_polygon_verts()
	var bone_idx = 0
	for each in voronoi:
		var bone := Bone2D.new()
		var point = each.fixed_center
		bone.name = "Bone-"+str(bone_idx)
		bone_idx += 1
		bone.global_position = point
		bone.set_autocalculate_length_and_angle(false)
		bone.set_length(vertex_interval)
		bones.append(bone)
	for bone in bones:
		bone.set_script(LookAtCenter2D)
	return bones

func _get_node_to_follow(bones_arr) -> Node:
	var center = Vector2()
	for bone in bones_arr:
		if bone != null:
			center = center + (bone as Node2D).global_position
	center = center / len(bones_arr)
	var dist_to_center = (bones_arr[0] as Node2D).global_position.distance_squared_to(center)
	var selected_bone = bones_arr[0]
	for bone in bones_arr:
		if bones_arr != null:
			var dist = (bone as Node2D).global_position.distance_squared_to(center)
			if dist < dist_to_center:
				dist_to_center = dist
				selected_bone = bone
	
	return selected_bone

func _generate_weights(bones: Array[Bone2D], voronoi, bone_vert_arr):
	var weights = []
	var bone_count = len(bones)
	var points_size = polygon.size()
	weights.resize(bone_count)
	for bone_index in bone_count:
		weights[bone_index] = []
		weights[bone_index].resize(points_size)
	# Set weights to bones and regions that they are part of
	for bone_index in bone_count:
		for point_idx in bone_vert_arr[bone_index]:
			weights[bone_index][point_idx] = 1
	# Set weights to regions close to the bone also
	for point_index in points_size:
		var point = polygon[point_index]
		var bones_data = []
		var dist_sum : float = 0
		
		for bone_index in bone_count:
			for poly in voronoi[bone_index].polygon_points:
				if _is_point_in_area(point, poly, 1.1):
					weights[bone_index][point_index] = 1
	return weights

func _sort_nearest_point(a, b) -> bool:
	return a[1] < b[1]

func _create_rigidbodies2d(skeleton: Skeleton2D):
	for child in get_children():
		if not child is Skeleton2D:
			remove_child(child)
			child.queue_free()
	var rigidbodies := _add_rigid_body_for_bones(skeleton)
	_generate_joints(rigidbodies)

func _add_rigid_body_for_bones(skeleton: Skeleton2D) -> Array[RigidBody2D]:
	var bones = skeleton.get_children()
	var center_bone := _get_node_to_follow(bones)
	var link_pair = {}
	var rigidbodies : Array[RigidBody2D] = []
	var polygon_limits = _calculate_polygon_limits()
	var max_dist_sq = polygon_limits[0].distance_squared_to(polygon_limits[1])/4
	for bone in bones:
		var distance_ratio = 1
		if soft_on_inside:
			var current_distance = bone.global_position.distance_squared_to(center_bone.global_position)
			if (current_distance <= 0.00001):
				current_distance = 0.00001
			distance_ratio = current_distance/max_dist_sq + 0.01
		var rigid_body = _create_rigid_body(skeleton, bone, mass * distance_ratio)
		rigid_body.set_meta("bone_name", bone.name)
		rigidbodies.append(rigid_body)
	return rigidbodies

func _create_rigid_body(skeleton: Skeleton2D, bone: Bone2D, mass):
	var rigid_body = RigidBody2D.new()
	rigid_body.name = bone.name
	var collision_shape = CollisionShape2D.new()
	var shape: Shape2D
	if shape_type == "Circle":
		shape = CircleShape2D.new()
		shape.radius = radius / 2.0
	elif shape_type == "Rectangle":
		shape = RectangleShape2D.new()
		shape.size = Vector2(radius, radius)
	else:
		push_error("Wrong shape used for shape_type")
	collision_shape.shape = shape
	collision_shape.name = shape_type + "Shape2D"
	rigid_body.mass = mass
	rigid_body.global_position = skeleton.transform * bone.position
	rigid_body.physics_material_override = physics_material_override
	rigid_body.add_child(collision_shape)
	rigid_body.collision_layer = collision_layer
	rigid_body.collision_mask = collision_mask
	rigid_body.input_pickable = pickable
	rigid_body.lock_rotation = lock_rotation
	rigid_body.set_script(rigidbody_script)
	var remote_transform = RemoteTransform2D.new()
	remote_transform.name = "RemoteTransform2D"
	rigid_body.add_child(remote_transform)
	remote_transform.remote_path = "../../" + skeleton.name + "/" + bone.name
	remote_transform.update_rotation = false
	remote_transform.update_scale = false
	remote_transform.use_global_coordinates = true
	add_child(rigid_body)
	if Engine.is_editor_hint():
		collision_shape.set_owner(get_tree().get_edited_scene_root())
		remote_transform.set_owner(get_tree().get_edited_scene_root())
		rigid_body.set_owner(get_tree().get_edited_scene_root())
	return rigid_body

func _generate_joints(rigid_bodies: Array[RigidBody2D]):
	var bones = get_node(skeleton).get_children()
	var connected_nodes_paths = []
	var connected_nodes = []
	for _i in bones.size():
		connected_nodes_paths.append([])
		connected_nodes.append([])
	for idx_a in len(rigid_bodies):
		var node_a := rigid_bodies[idx_a]
		for idx_b in len(rigid_bodies):
			var node_b := rigid_bodies[idx_b]
			if node_a == node_b or \
				node_a.global_position.distance_to(node_b.global_position) > vertex_interval * 1.5:
				continue
			connected_nodes_paths[idx_a].append(NodePath("../"+bones[idx_b].name))
			connected_nodes[idx_a].append(node_b)
			if joint_type == "pin":
				var joint = PinJoint2D.new()
				joint.name = "PinJoint2D-"+node_a.name+"-"+node_b.name
				joint.node_a = ".."
				joint.node_b = "../../" + node_b.name
				joint.softness = softness
				joint.disable_collision = disable_collision
				joint.look_at(node_b.global_position)
				joint.rotation = node_a.position.angle_to_point(node_b.position) - PI/2
				joint.bias = bias
				node_a.add_child(joint)
				joint.global_position = node_a.global_position
				if Engine.is_editor_hint():
					joint.set_owner(get_tree().get_edited_scene_root())
			else:
				var joint = DampedSpringJoint2D.new()
				joint.node_a = ".."
				joint.node_b = "../../" + node_b.name
				joint.stiffness = stiffness
				joint.disable_collision = disable_collision
				joint.rest_length = ((node_a.global_position - node_b.global_position).length()) * 1
				joint.length = ((node_a.global_position - node_b.global_position).length()) * 1
				joint.look_at(node_b.global_position)
				joint.rotation = node_a.position.angle_to_point(node_b.position) - PI/2
				joint.damping = damping
				joint.bias = bias
				node_a.add_child(joint)
				joint.global_position = node_a.global_position
				if Engine.is_editor_hint():
					joint.set_owner(get_tree().get_edited_scene_root())
	var follow_node := _get_node_to_follow(bones)
	for i in bones.size():
		var bone: LookAtCenter2D = bones[i]
		if look_at_center:
			bone.follow = [NodePath("../"+follow_node.name)]
			bone._follow_nodes = [follow_node]
			bone.look_at(LookAtCenter2D.get_dir_to_follow(bone.global_position, [follow_node]))
		else:
			bone.follow = connected_nodes_paths[i]
			bone._follow_nodes = connected_nodes[i]
			bone.look_at(LookAtCenter2D.get_dir_to_follow(bone.global_position, connected_nodes[i]))
		bone.set_rest(bone.transform)

# used internally, computed at _ready once
var _bones_array
var _soft_body_rigidbodies_array: Array[SoftBodyRigidBody2D]
var _soft_body_rigidbodies_dict: Dictionary

# Called when the node enters the scene tree for the first time.
func _ready():
	if !Engine.is_editor_hint():
		if get_child_count() == 0:
			push_warning("Softbody2d not created")
			return
		_bones_array = get_node(skeleton).get_children().filter(func(node): return node is Bone2D)
	_update_soft_body_rigidbodies()

## Remove joint between bone_a_name and bone_b_name. Useful if you want to make breakable softbodies.[br]
## This also handles recreating the polygon and correcting everything else so it works as expected.
func remove_joint(bone_a_name, bone_b_name):
	var polygon_weights: Array[float] = []
	polygon_weights.resize(len(polygon))
	var weights: Array[PackedFloat32Array] = []
	var bone_a_idx = -1
	var bone_b_idx = -1
	var bone_a: Bone2D
	var bone_b: Bone2D
	for i in len(_bones_array):
		var bone = _bones_array[i]
		if bone.name == bone_a_name:
			bone_a_idx = i
			bone_a = bone
		if bone.name == bone_b_name:
			bone_b_idx = i
			bone_b = bone
	
	var bone_a_weights = get_bone_weights(bone_a_idx)
	var bone_b_weights = get_bone_weights(bone_b_idx)
	var bone_a_owned_verts = _bones_array[bone_a_idx].get_meta("vert_owned")
	var bone_b_owned_verts = _bones_array[bone_b_idx].get_meta("vert_owned")
	for i in bone_a_weights.size():
		var should_remove_a = true
		var should_remove_b = true
		# both nodes have weight, check if it's not their own vert
		if bone_a_weights[i] > 0 && bone_b_weights[i] > 0:
			for point_a in bone_a_owned_verts:
				if i == point_a:
					should_remove_a = false
					break
			for point_b in bone_b_owned_verts:
				if i == point_b:
					should_remove_b = false
					break
			if should_remove_a:
				bone_a_weights[i] = 0.0
			if should_remove_b:
				bone_b_weights[i] = 0.0
	set_bone_weights(bone_a_idx, bone_a_weights)
	set_bone_weights(bone_b_idx, bone_b_weights)
	_update_soft_body_rigidbodies()

class SoftBodyRigidBody2D:
	var rigidbody: RigidBody2D
	var joints: Array[Joint2D]
	var shape: CollisionShape2D

## Get all the bodies, including joints and shape
func get_rigid_bodies() -> Array[SoftBodyRigidBody2D]:
	return _soft_body_rigidbodies_array

## Get the body located in the center
func get_center_body() -> SoftBodyRigidBody2D:
	var bodies := _soft_body_rigidbodies_array
	var rb_array := bodies.map(func(body): return body.rigidbody)
	var center_rb := _get_node_to_follow(bodies)
	return _soft_body_rigidbodies_dict[center_rb]
	
func _update_soft_body_rigidbodies():
	var result: Array[SoftBodyRigidBody2D]
	var children = get_children().filter(func (node: Node): return node is RigidBody2D)
	for child in children:
		var softbodyrb = SoftBodyRigidBody2D.new()
		softbodyrb.rigidbody = child as RigidBody2D
		var rb_children = child.get_children()
		softbodyrb.shape = rb_children.filter(func (node): return node is CollisionShape2D)[0]
		var joints = rb_children.filter(func (node): return node is Joint2D)
		for joint in joints:
			softbodyrb.joints.append(joint)
		result.append(softbodyrb)
		_soft_body_rigidbodies_dict[softbodyrb.rigidbody] = softbodyrb
	_soft_body_rigidbodies_array = result
